## 2. การเขียนโปรแกรมเชิงวัตถุ (OOP) ใน PHP

การเขียนโปรแกรมเชิงวัตถุ (Object-Oriented Programming: OOP) คือการแบ่งโค้ดออกเป็น “วัตถุ” (object) ซึ่งแต่ละวัตถุมีคุณสมบัติ (properties) และพฤติกรรม (methods) เป็นของตัวเอง แนวคิดนี้ช่วยให้การเขียนโปรแกรมมีโครงสร้างที่ชัดเจนและง่ายต่อการบำรุงรักษา ในสถานการณ์จริง เช่น หากคุณต้องพัฒนาเว็บแอปพลิเคชันสำหรับร้านค้าออนไลน์ คุณอาจมีวัตถุที่แทนสินค้า (Product) ผู้ใช้ (User) คำสั่งซื้อ (Order) และอื่น ๆ ซึ่งแต่ละวัตถุจะมีข้อมูลและพฤติกรรมเฉพาะตัว

---

### 2.1 การสร้างคลาสและออบเจ็กต์ (Class & Object)

**สถานการณ์:**  
ลองนึกภาพว่าคุณกำลังสร้างระบบรถยนต์ในโลกแห่งการจำลอง (simulation) คุณต้องการวัตถุที่แทนรถยนต์แต่ละคัน โดยแต่ละคันอาจมีสีที่แตกต่างกันและสามารถกระทำการ “ขับ” ได้

**ตัวอย่างและคำอธิบาย:**  
```php
<?php
  // สร้างคลาส Car ซึ่งเป็นแม่แบบสำหรับรถทุกคัน
  class Car {
      // กำหนด property เพื่อเก็บข้อมูลสีของรถ
      public $color;

      // สร้างเมธอด drive() เพื่อแสดงผลเมื่อรถกำลังขับ
      public function drive() {
          // ในสถานการณ์จริง คุณอาจส่งข้อมูลไปยังหน้าจอควบคุมหรือบันทึกการขับเคลื่อน
          echo "รถสี " . $this->color . " กำลังวิ่ง";
      }
  }

  // สร้างออบเจ็กต์ใหม่จากคลาส Car
  $myCar = new Car();

  // กำหนดสีให้กับรถ
  $myCar->color = "แดง"; // กำหนด property color

  // เรียกใช้เมธอด drive() เพื่อให้รถขับเคลื่อน
  $myCar->drive(); // ผลลัพธ์: "รถสี แดง กำลังวิ่ง"
?>
```

**เหตุผลที่ใช้:**  
- **คลาส:** ทำหน้าที่เป็นแม่แบบที่รวบรวมข้อมูล (สีของรถ) และการกระทำ (ขับรถ) ไว้ด้วยกัน  
- **ออบเจ็กต์:** คือสิ่งที่เกิดจากการสร้างคลาส ซึ่งในตัวอย่างคือรถยนต์แต่ละคันที่มีสีและพฤติกรรมของตัวเอง  
- **การใช้งานจริง:** ในระบบจำลองรถยนต์ คุณอาจมีหลายออบเจ็กต์ที่มีคุณสมบัติแตกต่างกัน ทำให้การจัดการและอัปเดตข้อมูลแต่ละคันเป็นไปได้ง่ายขึ้น

---

### 2.2 Access Modifiers (Encapsulation)

**สถานการณ์:**  
ลองนึกถึงระบบจัดการข้อมูลผู้ใช้ในแอปพลิเคชัน เมื่อคุณต้องการให้ข้อมูลสำคัญเช่น ชื่อผู้ใช้ หรือรหัสผ่านสามารถถูกแก้ไขได้เฉพาะภายในวัตถุ (คลาส) เท่านั้น เพื่อลดความเสี่ยงที่ข้อมูลสำคัญจะถูกแก้ไขจากภายนอก

**ตัวอย่างและคำอธิบาย:**  
```php
<?php
  class Person {
      // กำหนด property ที่เป็น private เพื่อป้องกันการเข้าถึงจากภายนอก
      private $name;

      // เมธอด setName() สำหรับตั้งค่าชื่อ
      public function setName($name) {
          // อาจมีการตรวจสอบความถูกต้องของข้อมูลก่อนบันทึกได้
          $this->name = $name;
      }

      // เมธอด getName() สำหรับดึงค่าชื่อออกมาใช้งาน
      public function getName() {
          return $this->name;
      }
  }

  // สร้างออบเจ็กต์ Person
  $person = new Person();

  // ตั้งค่าชื่อผ่านเมธอดที่ได้รับอนุญาตเท่านั้น
  $person->setName("Alice");

  // ดึงค่าชื่อและแสดงผล
  echo $person->getName(); // ผลลัพธ์: "Alice"
?>
```

**เหตุผลที่ใช้:**  
- **Encapsulation (การห่อหุ้ม):** ป้องกันไม่ให้ข้อมูลภายในถูกเข้าถึงหรือแก้ไขโดยตรงจากภายนอก ช่วยให้การควบคุมข้อมูลมีความปลอดภัยมากขึ้น  
- **Access Modifiers:** การใช้ `private` สำหรับ property ช่วยให้แน่ใจว่าเฉพาะเมธอดภายในคลาสเท่านั้นที่สามารถปรับปรุงข้อมูลได้  
- **สถานการณ์จริง:** ในระบบที่เกี่ยวข้องกับข้อมูลผู้ใช้ ข้อมูลส่วนตัวควรถูกซ่อนและเข้าถึงผ่านเมธอดที่ได้รับการตรวจสอบเท่านั้น

---

### 2.3 Constructors และ Destructors

**สถานการณ์:**  
ลองนึกถึงระบบจัดการผู้ใช้ในแอปพลิเคชัน เมื่อมีการสร้างออบเจ็กต์ผู้ใช้ใหม่ คุณอาจต้องการแสดงข้อความต้อนรับหรือกำหนดค่าเริ่มต้นให้กับวัตถุนั้นทันที  
นอกจากนี้ เมื่อผู้ใช้เลิกใช้งานระบบ อาจต้องมีการทำความสะอาดหรือบันทึกข้อมูลบางอย่างก่อนที่วัตถุจะถูกทำลาย

**ตัวอย่างและคำอธิบาย:**  
```php
<?php
  class User {
      public $name;

      // Constructor ถูกเรียกใช้ทันทีเมื่อสร้างออบเจ็กต์
      public function __construct($name) {
          // กำหนดค่าเริ่มต้นให้กับ property name
          $this->name = $name;
          // แจ้งข้อความว่าสร้างออบเจ็กต์แล้ว (สามารถใช้ในการบันทึก log ได้)
          echo "สร้างออบเจ็กต์สำหรับ " . $name . "<br>";
      }

      // Destructor ถูกเรียกใช้เมื่อออบเจ็กต์ถูกทำลายหรือหมดขอบเขตการใช้งาน
      public function __destruct() {
          // อาจใช้สำหรับทำความสะอาดทรัพยากรหรือบันทึกข้อมูลการใช้งาน
          echo "ทำลายออบเจ็กต์สำหรับ " . $this->name;
      }
  }

  // เมื่อสร้างออบเจ็กต์ User ข้อความใน constructor จะแสดงออกมา
  $user = new User("Bob");

  // เมื่อสิ้นสุดการทำงานหรือออกจากขอบเขตของตัวแปร $user, destructor จะถูกเรียกใช้
?>
```

**เหตุผลที่ใช้:**  
- **Constructor:** ช่วยกำหนดค่าเริ่มต้นให้กับออบเจ็กต์ ทำให้คุณมั่นใจว่าออบเจ็กต์ที่ถูกสร้างมานั้นมีสถานะพร้อมใช้งาน  
- **Destructor:** ใช้ในการทำความสะอาดหรือบันทึกข้อมูลเมื่อออบเจ็กต์ไม่ถูกใช้งานแล้ว ซึ่งเป็นสิ่งสำคัญในโปรแกรมที่จัดการกับทรัพยากร เช่น การเชื่อมต่อฐานข้อมูล  
- **สถานการณ์จริง:** ในระบบจัดการผู้ใช้ เมื่อมีการสร้างบัญชีใหม่ คอนสตรัคเตอร์อาจช่วยตั้งค่าการเริ่มต้น เช่น กำหนดบทบาทผู้ใช้ หรือเริ่มต้น session

---

### 2.4 Inheritance (การสืบทอดคลาส)

**สถานการณ์:**  
ลองนึกถึงระบบสัตว์ในสวนสัตว์ ที่คุณมีสัตว์หลายชนิด เช่น สุนัข แมว นก เป็นต้น แม้ว่าสัตว์ทุกชนิดจะมีพฤติกรรมพื้นฐานร่วมกัน (เช่น การเคลื่อนไหว) แต่บางชนิดอาจมีพฤติกรรมเฉพาะตัว (เช่น สุนัขเห่า, แมวร้อง)  
การใช้ Inheritance ช่วยให้คุณสร้างคลาสแม่ (Animal) ที่มีพฤติกรรมพื้นฐานไว้แล้ว จากนั้นให้คลาสลูก (Dog, Cat) สืบทอดและปรับเปลี่ยนพฤติกรรมเฉพาะของตัวเอง

**ตัวอย่างและคำอธิบาย:**  
```php
<?php
  // คลาสแม่ Animal มีเมธอด makeSound() ที่เป็นพื้นฐานสำหรับสัตว์ทุกชนิด
  class Animal {
      public function makeSound() {
          echo "เสียงสัตว์"; // พฤติกรรมเริ่มต้น
      }
  }

  // คลาส Dog สืบทอดคุณสมบัติจาก Animal และปรับเปลี่ยนเมธอด makeSound() ใหม่
  class Dog extends Animal {
      public function makeSound() {
          // ในสถานการณ์จริง สุนัขจะมีเสียงเห่า
          echo "สุนัขเห่า";
      }
  }

  // สร้างออบเจ็กต์ Dog และเรียกใช้เมธอด makeSound()
  $dog = new Dog();
  $dog->makeSound(); // ผลลัพธ์: "สุนัขเห่า"
?>
```

**เหตุผลที่ใช้:**  
- **Inheritance:** ช่วยให้คลาสลูกสามารถนำคุณสมบัติจากคลาสแม่มาใช้ซ้ำได้ ลดความซ้ำซ้อนของโค้ด  
- **การปรับเปลี่ยนพฤติกรรม:** คลาสลูกสามารถปรับเปลี่ยน (override) เมธอดที่ได้สืบทอดมาให้เหมาะสมกับตัวเอง  
- **สถานการณ์จริง:** เมื่อพัฒนาระบบที่มีหลายประเภทของวัตถุที่มีพฤติกรรมร่วมกัน แต่แตกต่างในรายละเอียด การใช้ inheritance ทำให้การจัดการง่ายและเพิ่มความยืดหยุ่น

---

### 2.5 Polymorphism (เมธอดที่มีชื่อเดียวกันแต่ทำงานต่างกัน)

**สถานการณ์:**  
ลองนึกถึงระบบวาดรูปในโปรแกรมกราฟิก ซึ่งคุณต้องการคำนวณพื้นที่ของรูปทรงต่าง ๆ เช่น สี่เหลี่ยมและวงกลม ถึงแม้ว่าจะใช้เมธอดชื่อเดียวกันในการคำนวณพื้นที่ แต่การคำนวณจะแตกต่างกันตามประเภทของรูปทรง  
การใช้ Polymorphism ช่วยให้คุณสามารถเรียกใช้เมธอดเดียวกันในหลายบริบทโดยที่ผลลัพธ์จะแตกต่างกันตามออบเจ็กต์ที่ถูกสร้าง

**ตัวอย่างและคำอธิบาย:**  
```php
<?php
  // กำหนด interface Shape เพื่อบังคับให้คลาสที่นำไปใช้ต้องมีเมธอด area()
  interface Shape {
      public function area();
  }

  // คลาส Square implements interface Shape
  class Square implements Shape {
      private $side;

      // Constructor กำหนดความยาวด้านของสี่เหลี่ยม
      public function __construct($side) {
          $this->side = $side;
      }

      // คำนวณพื้นที่สี่เหลี่ยม: ด้าน x ด้าน
      public function area() {
          return $this->side * $this->side;
      }
  }

  // คลาส Circle implements interface Shape
  class Circle implements Shape {
      private $radius;

      // Constructor กำหนดรัศมีของวงกลม
      public function __construct($radius) {
          $this->radius = $radius;
      }

      // คำนวณพื้นที่วงกลม: π x รัศมี²
      public function area() {
          return pi() * $this->radius * $this->radius;
      }
  }

  // สร้างออบเจ็กต์ของสี่เหลี่ยมและวงกลม
  $square = new Square(4);
  $circle = new Circle(3);

  // แสดงผลพื้นที่ โดยใช้เมธอด area() ที่มีชื่อเดียวกันแต่ทำงานแตกต่างกัน
  echo "พื้นที่สี่เหลี่ยม: " . $square->area() . "<br>";
  echo "พื้นที่วงกลม: " . $circle->area();
?>
```

**เหตุผลที่ใช้:**  
- **Polymorphism:** ช่วยให้คุณสามารถใช้เมธอดชื่อเดียวกัน (เช่น area()) กับออบเจ็กต์ที่แตกต่างกันได้โดยไม่ต้องสนใจชนิดของออบเจ็กต์  
- **ความยืดหยุ่น:** เพิ่มความสามารถในการเขียนโค้ดที่ปรับเปลี่ยนได้ง่ายเมื่อต้องรองรับรูปทรงใหม่ ๆ ในอนาคต  
- **สถานการณ์จริง:** โปรแกรมวาดรูปหรือคำนวณพื้นที่ของรูปทรงต่าง ๆ ที่มีการประมวลผลคล้ายกัน แต่มีสูตรการคำนวณที่แตกต่างกัน

---

### 2.6 Trait (แนวคิดการใช้โค้ดร่วมกัน)

**สถานการณ์:**  
ลองนึกถึงระบบสั่งซื้อในร้านค้าออนไลน์ที่มีหลายโมดูล เช่น การจัดการคำสั่งซื้อ, การจัดส่งสินค้า, และการบันทึกประวัติการทำงาน  
ในบางกรณี โมดูลเหล่านี้อาจต้องการฟังก์ชันสำหรับบันทึก log หรือเก็บข้อมูลการทำงานร่วมกัน โดยที่ไม่เกี่ยวข้องกันในเชิงของการสืบทอด  
การใช้ Trait ช่วยให้คุณสามารถนำฟังก์ชันที่ใช้ร่วมกันมาแทรกลงในคลาสต่าง ๆ ได้โดยไม่ต้องทำ inheritance

**ตัวอย่างและคำอธิบาย:**  
```php
<?php
  // สร้าง Trait Logger ที่มีเมธอด log() สำหรับบันทึกข้อความ log
  trait Logger {
      public function log($message) {
          // ในสถานการณ์จริง คุณอาจบันทึกลงไฟล์หรือฐานข้อมูล
          echo "[LOG]: " . $message;
      }
  }

  // คลาส Order ที่ใช้ Trait Logger เพื่อให้สามารถบันทึก log ได้
  class Order {
      // ใช้ Trait Logger เพื่อรวมฟังก์ชัน log() เข้าไปในคลาส Order
      use Logger;

      // เมธอด process() จำลองกระบวนการประมวลผลคำสั่งซื้อ
      public function process() {
          // ก่อนประมวลผลอาจต้องบันทึก log เกี่ยวกับการเริ่มต้นประมวลผล
          $this->log("กำลังประมวลผลคำสั่งซื้อ");
          // กระบวนการประมวลผลอื่น ๆ ที่จำลองขึ้น เช่น ตรวจสอบสินค้าคงคลัง
          echo "<br>ประมวลผลคำสั่งซื้อเสร็จสิ้น";
      }
  }

  // สร้างออบเจ็กต์ Order แล้วเรียกใช้เมธอด process()
  $order = new Order();
  $order->process();
?>
```

**เหตุผลที่ใช้:**  
- **Trait:** ช่วยให้คุณสามารถแชร์ฟังก์ชันหรือพฤติกรรมร่วมกันระหว่างคลาสที่ไม่เกี่ยวข้องกันในสายสัมพันธ์ของ inheritance  
- **ลดความซ้ำซ้อน:** ไม่จำเป็นต้องเขียนโค้ด log ซ้ำในแต่ละคลาสที่ต้องการฟังก์ชันนี้  
- **สถานการณ์จริง:** ในแอปพลิเคชันขนาดใหญ่ที่มีหลายโมดูล การใช้ Trait ช่วยให้โค้ดมีความเป็นโมดูลและบำรุงรักษาได้ง่ายขึ้น

---

## สรุปการนำเสนอแนวคิด OOP ด้วยเหตุการณ์ประกอบ

- **การสร้างคลาสและออบเจ็กต์:**  
  นำเสนอผ่านตัวอย่างระบบรถยนต์ในโลกจำลอง ที่แต่ละรถมีสีและพฤติกรรม “ขับ” เป็นการทำให้เห็นภาพว่าการแบ่งวัตถุเป็นส่วน ๆ ทำให้ระบบมีโครงสร้างชัดเจน

- **Encapsulation ด้วย Access Modifiers:**  
  ใช้ตัวอย่างระบบจัดการผู้ใช้ที่ต้องการป้องกันข้อมูลสำคัญจากการถูกเข้าถึงโดยตรง เพื่อสร้างความเข้าใจว่าข้อมูลสำคัญควรได้รับการควบคุมอย่างไร

- **Constructors และ Destructors:**  
  นำเสนอผ่านระบบจัดการผู้ใช้ที่มีการแสดงข้อความต้อนรับและทำความสะอาดทรัพยากร ช่วยให้เข้าใจการเริ่มต้นและสิ้นสุดการใช้งานของวัตถุ

- **Inheritance:**  
  ใช้ตัวอย่างระบบสัตว์ในสวนสัตว์เพื่อแสดงว่าคลาสลูกสามารถรับคุณสมบัติพื้นฐานจากคลาสแม่และปรับเปลี่ยนได้ตามความต้องการ

- **Polymorphism:**  
  นำเสนอผ่านระบบคำนวณพื้นที่ของรูปทรงต่าง ๆ ที่ใช้เมธอดชื่อเดียวกันแต่มีสูตรคำนวณที่แตกต่างกัน เพื่อเน้นถึงความยืดหยุ่นในการออกแบบโปรแกรม

- **Trait:**  
  ใช้ตัวอย่างระบบสั่งซื้อที่ต้องใช้ฟังก์ชันบันทึก log ร่วมกันในหลายโมดูล โดยที่ไม่เกี่ยวข้องกันโดยตรงในเชิง inheritance เพื่อแสดงว่าการแชร์ฟังก์ชันร่วมกันช่วยลดความซ้ำซ้อนและเพิ่มประสิทธิภาพในการพัฒนา

---